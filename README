Experiment in Semi-manual binding between C++ and Lua.
See headers files for author and license info.

LuaBinding.h

Basically make the boring and slightly difficult stuff easier, but leaving the more fun
not so hard stuff to do. :-)

The memory management, life-cycle, and method despatch is the same for each
bound class, only the glue functions that marshal the parameters are
different.

Hand writing the glue functions also allows them to be as complicated or as
simple as required.  For example you could support optional arguments, or even
overloading.

Shared pointers are used to simplify the question of who owns what, and who
should delete it. Class instances can be created in Lua or C++ and passed to
the other freely, as the last one holding a reference will call the
destructor when required.

There now is a POD or plain old data version of the binding for things like pointers or
tiny classes and structs. These get copied around unlike the shared pointer version which 
keeps one and only one copy.

LuaRef.h 
C++ management of lua data. A re-write of code originally written by me and then 
donated to LuaBridge. 
This version I have changed to use c++11 variable template arguments for
calling Lua, The table element proxy is now public, and the code structure is
re-arranged to put shared functionality between LuaRef, and TableElement in a 
base class.

LuaException.h
Supprot for throwing on Lua errors. Used by LuaRef.

LuaStack.h
From LuaBridge. The original LuaRef.h was changed to use this. I didn't want to reverse
that. Originally called Stack.h. If I wrote this myself, it would look almost the same
anyhow. :-)
